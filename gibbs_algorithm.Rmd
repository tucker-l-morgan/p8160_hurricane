---
title: "Gibbs Sampling Algorithm"
author: ""
date: "5/4/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(MASS)
```

```{r importing data}
hurr_df <- read_csv("./data/hurricane703.csv") %>% 
  group_by(ID) %>% 
  filter(n() > 1) %>% 
  # create delta variables and wind lag - wind speed at time t, Y(t)
  mutate(lat_change = c(0, diff(Latitude, lag = 1)), # I put zero for first entry, could be NA
         lng_change = c(0, diff(Longitude, lag = 1)),
         wind_change = c(0, diff(Wind.kt, lag = 1)),
         wind_lag = lag(Wind.kt, n = 1)) %>% 
  select(ID, lat_change, lng_change, wind_change, wind_lag, Wind.kt) %>% 
  nest(y = Wind.kt, x = lat_change:wind_lag) %>%  
  mutate(x = map(.x = x, .f = ~model.matrix(~., data = .x)),
         y = map(.x = y, .f = pull))

hurr_list <- list(
  y = hurr_df$y,
  x = hurr_df$x
)


# you can extract data like this
hurr_list$x[[1]]
hurr_list$y[[1]]

# list of theta parameters
theta <- list(
  "beta" = matrix(data = 0, nrow = 1, ncol = 5),
  "B" = matrix(data = 0, nrow = nrow(hurr_df), ncol = 5),
  "sigma2" = c(3),
  "sigma_m" = matrix(data = 1, nrow = 5, ncol = 5) + diag(1, 5, 5)
)
```

```{r log posterior distributions}
# log posterior of sigma^2
log_sigma2 <- function(data, i){
  # alpha parameter of distribution
  alpha = 1 + sum(dim(data[[i]]$y)) / 2
  # beta parameter of distribution
  b = (1/2) * sum(t(data[[i]]$y - data[[i]]$x %*% t(theta$beta)) %*% diag(length(data[[i]]$y)) %*% (data[[i]]$y - data[[i]]$x %*% t(theta$beta)))
  # pulling sigma^2 from theta list
  tau = theta$sigma2
  
  return(alpha * log(b) - log(gamma(alpha)) + (alpha - 1) * log(tau) - tau * b)
}

# log posterior of beta
log_beta <- function(){
  v = sum(theta$sigma_m)
  u = sum(theta$sigma_m %*% t(theta$beta))
  
  return(-(1/2) * log(det(2 * pi * solve(v))) - (1/2) * t((theta$beta - solve(v) %*% u)) %*% solve(v) %*% (theta$beta - solve(v) %*% u))
}

# log posterior of B
log_B <- function(data, i){
  v = t(data$x[[i]]) %*% (1 / diag(theta$sigma2)) %*% data[[i]]$x + theta$sigma_m
  u = data[[i]]$x %*% (1 / diag(theta$sigma2)) %*% data[[i]]$y + theta$sigma_m %*% t(theta$beta)
  
  return(-(1/2) * log(det(2 * pi * solve(v))) - (1/2) * t((theta$B - solve(v) %*% u)) %*% solve(v) %*% (theta$B - solve(v) %*% u))
}
```

```{r conditional distributions}
beta_dist <- function(){
  v = (theta$sigma_m)
  u = (theta$sigma_m %*% t(theta$beta))
  
  mu = solve(v) %*% u
  sigma = solve(v)
  
  sample = mvrnorm(n = 1, mu, sigma)
  
  return(sample)
}

B_dist <- function(data){
  B_list <- list()
  
  for(i in 1:nrow(hurr_df)){
    if(length(data$y[[i]]) < 2){
      next
    }
    attr(data$x[[i]], which = "assign") <- NULL
    attr(data$x[[i]], which = "dimnames") <- NULL
    y_adj <- data$y[[i]][-1]
    
    mat <- diag(theta$sigma2, nrow = length(y_adj), ncol = length(y_adj))
    
    u <- t(data$x[[i]]) %*% solve(a = mat) %*% y_adj + solve(theta$sigma_m) %*% t(theta$beta)
    v <- t(data$x[[i]]) %*% solve(a = mat) %*% data$x[[i]] + solve(theta$sigma_m)
    
    mu <- solve(v) %*% u
    sigma <- solve(v)
    
    B_list[[i]] <- mvrnorm(n = 1, mu, sigma)
    
  }
  
  B_matrix <- do.call(rbind, B_list)
  
  return(B_matrix)
}

beta_helper <- function(x, y, beta_i){
  t(y - x %*% t(beta_i)) %*% (y - x %*% t(beta_i))
}

sigma2_dist <- function(data){
  length_vec = sapply(data$y, length)

  beta_vec <- c()
  for(i in 1:nrow(hurr_df)){
    attr(data$x[[i]], which = "assign") <- NULL
    attr(data$x[[i]], which = "dimnames") <- NULL
    y_adj <- data$y[[i]][-1]
    
    res <- t(y_adj - data$x[[i]] %*% theta$B[i,]) %*% diag(length(y_adj)) %*% (y_adj - data$x[[i]] %*% (theta$B[i,]))
    
    beta_vec[i] <- res
  }
  
  # alpha parameter of distribution
  alpha = 1 + sum(length_vec) / 2
  # beta parameter of distribution
  b = (1/2) * sum(beta_vec)
  
  sample = rgamma(n = 1, shape = alpha, rate = b)
  return(sample)
}

sigma_m_dist <- function(){
 prev_matrix <- matrix(0, nrow = 5, ncol = 5)
 
 for(i in 1:nrow(hurr_df)){
   
   matrix <- prev_matrix + t(theta$B[i,] - theta$beta) %*% (theta$B[i,] - theta$beta) + diag(nrow = 5, ncol = 5)
   
   prev_matrix <- matrix
 }
 
 matrix <- matrix + diag(1, 5, 5)
 
 mat_param <- solve(matrix)
  
 d = 5
 n = nrow(hurr_df)
  
 sample = rWishart(n = 1, df = d + 1 + n, Sigma = mat_param)
  return(sample)
}
```

